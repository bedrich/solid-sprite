#!/usr/bin/env node

var fs = require('fs');
var nopt = require('nopt');
var colors = require('colors');
var exec = require('child_process').exec;
var path = require('path');

var opts = {
	'grid': Number,
	'trim': Boolean
};

var short_hands = {
	't': ['--trim'],
	'g': ['--grid']
};

// Parse options
var opts = nopt(opts, short_hands, process.argv);

// Determine input and output from remaining arguments
var paths = opts.argv.remain;
var path_input;
var path_output;

// We should only have an input and output as the remaining args
if (paths.length !== 2) {
	console.log('Something doesn\'t seem right, make sure your command looks like this:'.yellow);
	console.log('solidsprite [input_dir] [output_file] [options]');
	process.exit(1);

} else {
	path_input = paths[0];
	path_output = paths[1];
}

// Make sure the input dir exists
if (!fs.existsSync(path_input)) {
	console.log('✖ '.red + path_input + ' does not exist.');
	process.exit(1);

// ... determine fullpath to images inside input dir
} else {
	opts.images = fs.readdirSync(path_input).map(function(img) {
		return path.join(path_input, img);
	});
}

if (!opts.trim) {
	createSprite();
} else {
	trimImages(createSprite);
}

function trimImages (cb) {
	console.log('‣' + ' Trimming images...');
	exec('mogrify -trim ' + opts.images.join(' '), function (err, stdout, stderr) {
		if (err) throw err;
		console.log('✓'.green + ' Trimming completed');
		cb.call();
	});
}

function createSprite () {
	console.log('‣' + ' Piecing sprite together...');
	exec('identify ' + opts.images.join(' '), function (err, stdout, stderr) {
		if (err) throw err;
		var images_metadata = formatIdentify(stdout.split('\n'));

		exec('convert ' + formatMontageArgs(images_metadata), function (err, stdout, stderr) {
			if (err) throw err;
			console.log('✓'.green + ' Sprite completed.');
			console.log('‣ ' + path_output);
		});
	});
}

function formatIdentify (id_arr) {
	var id_formatted = {
		info: { maxwidth: 0 },
		imgs: []
	};

	for (var i = 0, len= id_arr.length; i < len; i++) {
		var id_info = id_arr[i].split(' ');

		if (id_info.length > 1) {
			id_formatted.info.maxwidth = Math.max(id_formatted.info.maxwidth, id_info[2].split('x')[0]);
			id_formatted.imgs.push({
				'filepath': (i > 0) ? id_info[0].slice(0, -(2 + i.toString().length)) : id_info[0], // removes "[i]" from end of string
				'filetype': id_info[1],
				'size': {
					'h': id_info[2].split('x')[1],
					'w': id_info[2].split('x')[0]
				}
			});
		}
	}

	return id_formatted;
}

function formatMontageArgs(metadata) {
	var args = [];
	var y_pos = 0;

	for (var i = 0, len = metadata.imgs.length; i < len; i++) {
		var img = metadata.imgs[i];
		var grid = opts.grid || 1;
		var square_pos = (y_pos / grid);

		args.push(
			'-background',
			'gray',
			'-pointsize',
			'11',
			'-font',
			'Helvetica',
			'-fill',
			'white',
			'-page',
			['+', metadata.info.maxwidth + grid, '+', y_pos].join(''),
			['label:', '[', square_pos, ']', img.size.w, 'x', img.size.h].join(''),
			'-page',
			['+0+', y_pos].join(''),
			img.filepath);

		if (img.size.h > grid) {
			y_pos += Math.ceil(img.size.h / grid) * grid;
		} else {
			y_pos += grid;
		}
	}

	args.push(
		'-background',
		'none',
		'-mosaic',
		path_output);
	return args.join(' ');
}
